<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on XS-Leaks Wiki</title><link>https://xsleaks.dev/</link><description>Recent content in Introduction on XS-Leaks Wiki</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://xsleaks.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Resource Isolation Policy</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/resource-isolation/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/isolation-policies/resource-isolation/</guid><description>&lt;p>Resource Isolation Policy prevents external websites from requesting your resources. Blocking such traffic mitigates common web vulnerabilities such as CSRF, XSSI, or XS-Leaks. The policy can be enabled for applications whose endpoints are not intended to be loaded in a cross-site context and will allow resource requests coming from your application as well as direct navigations.&lt;/p>
&lt;h2 id="implementation-with-fetch-metadata">
 Implementation with Fetch Metadata
 &lt;a class="anchor" href="#implementation-with-fetch-metadata">#&lt;/a>
&lt;/h2>
&lt;p>The below snippet showcases an example implementation of the Resource Isolation Policy with the use of &lt;a href="https://xsleaks.dev/docs/defenses/opt-in/fetch-metadata/">Fetch Metadata&lt;/a> headers:&lt;/p></description></item><item><title>Clocks</title><link>https://xsleaks.dev/docs/attacks/timing-attacks/clocks/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/timing-attacks/clocks/</guid><description>&lt;p>We can distinguish two types of clocks â€“ explicit and implicit. Explicit clocks are used by developers to get direct timing measurements, mechanisms of this type are offered explicitly by the browser. In contrast, implicit clocks utilize particular web features to create unintended clocks that allow measuring the relative passage of time.&lt;/p>
&lt;h2 id="explicit-clocks">
 Explicit Clocks
 &lt;a class="anchor" href="#explicit-clocks">#&lt;/a>
&lt;/h2>
&lt;h3 id="performancenow-api">
 performance.now API
 &lt;a class="anchor" href="#performancenow-api">#&lt;/a>
&lt;/h3>
&lt;p>The &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now">performance.now()&lt;/a> API allows developers to get high-resolution timing measurements.&lt;/p>

 &lt;blockquote class="book-hint2 info">
 &lt;p class="hint-title info">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#info-notice">&lt;/use>
 &lt;/svg>&lt;span>info&lt;/span>&lt;/p></description></item><item><title>XS-Search</title><link>https://xsleaks.dev/docs/attacks/xs-search/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/xs-search/</guid><description>&lt;p>Cross-site search (XS-Search) is an important attack principle in the family of XS-Leaks. This type of attack abuses Query-Based Search Systems to leak user information from an attacker origin &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. The original attack uses timing measurements to detect whether or not a search system returns results and works as follows:&lt;/p>
&lt;ol>
&lt;li>Establish a baseline of the time needed for a request to return results (hit), and a baseline for the time needed by a request with no results (miss).&lt;/li>
&lt;li>Start a &lt;a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/">timing attack&lt;/a> on the request to the search endpoint, brute-forcing the first character (&lt;code>?q=r&lt;/code>).&lt;/li>
&lt;li>If the measurement is under the hit baseline, then add one more character (&lt;code>?q=ra&lt;/code>); otherwise try a new one (&lt;code>?q=s&lt;/code>).&lt;/li>
&lt;li>In the end, a full secret (&lt;code>?q=secret&lt;/code>) can be leaked.&lt;/li>
&lt;/ol>
&lt;p>This attack requires multiple timing measurements to be accurate, something which can be improved with inflation techniques and statistical analysis. Furthermore, instead of brute-forcing letter by letter, attackers can search specific words or sentences to leak only the occurrence of results.&lt;/p></description></item><item><title>Framing Isolation Policy</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/framing-isolation/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/isolation-policies/framing-isolation/</guid><description>&lt;p>Framing Isolation Policy is a stricter version of &lt;a href="https://xsleaks.dev/docs/defenses/opt-in/xfo/">Framing Protections&lt;/a> where the request gets blocked at the application level rather than by the browser. This is designed to protect against various attacks (e.g. XSSI, CSRF, XS-Leaks) by blocking framing requests to endpoints that are not intended to be framable.&lt;/p>
&lt;p>It can be combined with &lt;a href="https://xsleaks.dev/docs/defenses/isolation-policies/resource-isolation/">Resource Isolation Policy&lt;/a> to effectively tighten the attack surface within cross-site information leaks.&lt;/p>

 &lt;blockquote class="book-hint2 tip">
 &lt;p class="hint-title tip">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#tip-notice">&lt;/use>
 &lt;/svg>&lt;span>tip&lt;/span>&lt;/p>
 Instead of rejecting all non-framable endpoints, the user could be prompted to confirm the action, e.g. &lt;em>Confirm that you visited this page from a trusted origin&lt;/em>, to mitigate the risk of attacks in the background, and, at the same time, help prevent unintended breakages of an application.
 &lt;/blockquote>



 &lt;blockquote class="book-hint2 tip">
 &lt;p class="hint-title tip">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#tip-notice">&lt;/use>
 &lt;/svg>&lt;span>tip&lt;/span>&lt;/p></description></item><item><title>Window References</title><link>https://xsleaks.dev/docs/attacks/window-references/</link><pubDate>Thu, 08 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/window-references/</guid><description>&lt;p>If a page sets its &lt;code>opener&lt;/code> property to &lt;code>null&lt;/code> or is using &lt;a href="https://xsleaks.dev/docs/defenses/opt-in/coop/">COOP&lt;/a> protection depending on the users&amp;rsquo; state, it becomes possible to infer cross-site information about that state. For example, attackers can detect whether a user is logged in by opening an endpoint in an iframe (or a new window) which only authenticated users have access to, simply by checking its window reference. &lt;a href="https://xsinator.com/testing.html#COOP%20Leak">Run demo&lt;/a>&lt;/p>
&lt;h2 id="code-snippet">
 Code Snippet
 &lt;a class="anchor" href="#code-snippet">#&lt;/a>
&lt;/h2>
&lt;p>The below snippet demonstrates how to detect whether the &lt;code>opener&lt;/code> property was set to &lt;code>null&lt;/code>, or whether the &lt;a href="https://xsleaks.dev/docs/defenses/opt-in/coop/">COOP&lt;/a> header is present with a value other than &lt;code>unsafe-none&lt;/code>. This can be done with both iframes and new windows.&lt;/p></description></item><item><title>CORB Leaks</title><link>https://xsleaks.dev/docs/attacks/browser-features/corb/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/browser-features/corb/</guid><description>&lt;p>&lt;a href="https://xsleaks.dev/docs/defenses/secure-defaults/corb/">Cross-Origin Read Blocking&lt;/a> (CORB) is a web platform security feature aimed at reducing the impact of speculative side-channel attacks such as Spectre. Unfortunately, blocking certain types of requests introduced a new type of XS-Leaks &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> that allows attackers to detect if CORB was enforced on one request, but wasn&amp;rsquo;t on another. Nevertheless, the introduced XS-Leaks are much less problematic than the issues actively protected by CORB (e.g. Spectre).&lt;/p>

 &lt;blockquote class="book-hint2 info">
 &lt;p class="hint-title info">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#info-notice">&lt;/use>
 &lt;/svg>&lt;span>info&lt;/span>&lt;/p></description></item><item><title>CORP Leaks</title><link>https://xsleaks.dev/docs/attacks/browser-features/corp/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/browser-features/corp/</guid><description>&lt;h2 id="explanation">
 Explanation
 &lt;a class="anchor" href="#explanation">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://xsleaks.dev/docs/defenses/opt-in/corp/">Cross-Origin Resource Policy&lt;/a> (CORP) is a web platform security feature that allows websites to prevent certain resources from being loaded by other origins. This protection complements &lt;a href="https://xsleaks.dev/docs/defenses/secure-defaults/corb/">CORB&lt;/a> since it is an opt-in defense, whereas CORB blocks some cross-origin reads by default. Unfortunately, similar to &lt;a href="https://xsleaks.dev/docs/attacks/browser-features/corb/">CORB&lt;/a>, applications can introduce a new XS-Leak if they misconfigure the use of this protection.&lt;/p>
&lt;p>A webpage will introduce an XS-Leak if &lt;code>CORP&lt;/code> is enforced based on user data. If a page search feature enforces &lt;code>CORP&lt;/code> when showing results, but doesn&amp;rsquo;t do so when returning no results, an attacker will be able to distinguish the two scenarios. This occurs because a page/resource protected by &lt;code>CORP&lt;/code> will return an error when fetched cross-origin. &lt;a href="https://xsinator.com/testing.html#CORP%20Leak">Run demo&lt;/a>&lt;/p></description></item><item><title>CSS Tricks</title><link>https://xsleaks.dev/docs/attacks/css-tricks/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/css-tricks/</guid><description>&lt;h2 id="css-tricks">
 CSS Tricks
 &lt;a class="anchor" href="#css-tricks">#&lt;/a>
&lt;/h2>
&lt;p>CSS can be used to trick a user into exposing information such as embedded pixel values by making visual changes that are affected by the embed.&lt;/p>
&lt;h2 id="retrieving-users-history">
 Retrieving user&amp;rsquo;s history
 &lt;a class="anchor" href="#retrieving-users-history">#&lt;/a>
&lt;/h2>
&lt;p>Using the CSS &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:visited">&lt;code>:visited&lt;/code>&lt;/a> selector, itâ€™s possible to apply a different style for URLs that have been visited.&lt;br>
Previously it was possible to use &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle">&lt;code>getComputedStyle()&lt;/code>&lt;/a> to detect this difference, but now browsers prevent this by always returning values as if the link was visited and limiting what styles can be applied using the selector. &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;br>
So, it may be needed to trick the user into clicking an area that the CSS has affected.
This can be done using &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode">&lt;code>mix-blend-mode&lt;/code>&lt;/a>. &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;br>
There are also ways to do it without user interaction such as by abusing render timings.
This works because it takes time to paint links in a different color. &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;br>
A Proof of Concept to this attack can be found in a Chromium report &lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> and it works by having multiple links to increase the time difference.&lt;/p></description></item><item><title>Error Events</title><link>https://xsleaks.dev/docs/attacks/error-events/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/error-events/</guid><description>&lt;p>When a webpage issues a request to a server (e.g. fetch, HTML tags), the server receives and processes this request. When received, the server decides whether the request should succeed (e.g. 200) or fail (e.g. 404) based on the provided context. When a response has an error status, an &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/error_event">error event&lt;/a> is fired by the browser for the page to handle. These errors also cover situations where the parser fails, for example when trying to embed &lt;code>HTML&lt;/code> content as an image.&lt;/p></description></item><item><title>Frame Counting</title><link>https://xsleaks.dev/docs/attacks/frame-counting/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/frame-counting/</guid><description>&lt;p>Window references allow cross-origin pages to get access to some of the attributes of other pages. These references become available when using or allowing &lt;code>iframe&lt;/code> and &lt;code>window.open&lt;/code>. The references provide (limited) information about the window as they still respect the same-origin policy.&lt;/p>
&lt;p>One of the accessible attributes is &lt;code>window.length&lt;/code> which provides the number of frames in the window. This attribute can provide valuable information about a page to an attacker.&lt;/p></description></item><item><title>Navigations</title><link>https://xsleaks.dev/docs/attacks/navigations/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/navigations/</guid><description>&lt;p>Detecting if a cross-site page triggered a navigation (or didn&amp;rsquo;t) can be useful to an attacker. For example, a website may trigger a navigation in a certain endpoint &lt;a href="#case-scenarios">depending on the status of the user&lt;/a>.&lt;/p>
&lt;p>To detect if any kind of navigation occurred, an attacker can:&lt;/p>
&lt;ul>
&lt;li>Use an &lt;code>iframe&lt;/code> and count the number of times the &lt;code>onload&lt;/code> event is triggered.&lt;/li>
&lt;li>Check the value of &lt;code>history.length&lt;/code>, which is accessible through any window reference. This provides the number of entries in the history of a victim that were either changed by &lt;code>history.pushState&lt;/code> or by regular navigations. To get the value of &lt;code>history.length&lt;/code>, an attacker changes the location of the window reference to the target website, then changes back to same-origin, and finally reads the value. &lt;a href="https://xsinator.com/testing.html#History%20Length%20Leak">Run demo&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="download-trigger">
 Download Trigger
 &lt;a class="anchor" href="#download-trigger">#&lt;/a>
&lt;/h2>
&lt;p>When an endpoint sets the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition">&lt;code>Content-Disposition: attachment&lt;/code>&lt;/a> header, it instructs the browser to download the response as an attachment instead of navigating to it. Detecting if this behavior occurred might allow attackers to leak private information if the outcome depends on the state of the victim&amp;rsquo;s account.&lt;/p></description></item><item><title>Network Timing</title><link>https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/</guid><description>&lt;p>Network Timing side-channels have been present on the web since its inception &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. These attacks have had different levels of impact over time, gaining new attention when browsers started shipping high-precision timers like &lt;a href="https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow">performance.now()&lt;/a>.&lt;/p>
&lt;p>To obtain timing measurements, attackers must use a &lt;a href="https://xsleaks.dev/docs/attacks/timing-attacks/clocks/">clock&lt;/a>, either an implicit or an explicit one. These clocks are usually interchangeable for the purposes of XS-Leaks and only vary in accuracy and availability. For simplicity, this article assumes the use of the &lt;code>performance.now()&lt;/code> API, an explicit clock present in all modern browsers.&lt;/p></description></item><item><title>Performance API</title><link>https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/</guid><description>&lt;h2 id="performance-api">
 Performance API
 &lt;a class="anchor" href="#performance-api">#&lt;/a>
&lt;/h2>
&lt;p>The &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance">&lt;code>Performance API&lt;/code>&lt;/a> provides access to performance-related information enhanced by the data from the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API">&lt;code>Resource Timing API&lt;/code>&lt;/a>
which provides the timings of network requests such as the duration but when thereâ€™s a &lt;code>Timing-Allow-Origin: *&lt;/code> header sent by the server the transfer size and domain lookup time is also provided.&lt;br>
This data can be accessed by using &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries">&lt;code>performance.getEntries&lt;/code>&lt;/a> or &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName">&lt;code>performance.getEntriesByName&lt;/code>&lt;/a>
It can also be used to get the execution time using the difference of &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now">&lt;code>performance.now()&lt;/code>&lt;/a> however this seems to be less precise for a chrome fetch because it only provides the milliseconds.&lt;/p></description></item><item><title>Cache Probing</title><link>https://xsleaks.dev/docs/attacks/cache-probing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/cache-probing/</guid><description>&lt;p>The principle of Cache Probing consists of detecting whether a resource was cached by the browser. The concept has been known since the beginning of the web &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> and initially relied on detecting timing differences.&lt;/p>
&lt;p>When a user visits a website, some resources such as images, scripts, and HTML content are fetched and later cached by the browser (under certain conditions). This optimization makes future navigations faster as the browser serves those resources from disk instead of requesting them again. If an attacker can detect which resources are cached, this information can be enough to leak whether a user accessed a specific page in the past.&lt;/p></description></item><item><title>Element leaks</title><link>https://xsleaks.dev/docs/attacks/element-leaks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/element-leaks/</guid><description>&lt;p>Some HTML Elements might be used to leak a portion of data to a cross-origin page.
For example, the below media resources can leak information about its size, duration, type.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement">HTMLMediaElement&lt;/a> leaks the media &lt;code>duration&lt;/code> and the &lt;code>buffered&lt;/code> times. &lt;a href="https://xsinator.com/testing.html#Media%20Duration%20Leak">Run demo&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement">HTMLVideoElement&lt;/a> leaks the &lt;code>videoHeight&lt;/code> and &lt;code>videoWidth&lt;/code>
some browsers may also have &lt;code>webkitVideoDecodedByteCount&lt;/code>, &lt;code>webkitAudioDecodedByteCount&lt;/code> and &lt;code>webkitDecodedFrameCount&lt;/code>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality">getVideoPlaybackQuality()&lt;/a> leaks the &lt;code>totalVideoFrames&lt;/code>.&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement">HTMLImageElement&lt;/a> leaks the &lt;code>height&lt;/code> and &lt;code>width&lt;/code> but if the image is invalid they will be 0
and &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode">&lt;code>image.decode()&lt;/code>&lt;/a> will get rejected. &lt;a href="https://xsinator.com/testing.html#Media%20Dimensions%20Leak">Run demo&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>It&amp;rsquo;s possible to differentiate between media types via unique property for a given media type. For example, it is &lt;code>videoWidth&lt;/code> for a &lt;code>&amp;lt;video&amp;gt;&lt;/code>, or &lt;code>duration&lt;/code> for an &lt;code>&amp;lt;audio&amp;gt;&lt;/code>. The below snippet shows an example code that returns the type of a resource.&lt;/p></description></item><item><title>Navigation Isolation Policy</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/navigation-isolation/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/isolation-policies/navigation-isolation/</guid><description>&lt;p>Navigation Isolation Policy is a server-side protection mechanism intended to mitigate CSRF, clickjacking, reflected XSS, and XS-Leaks that make use of cross-site window contexts. This is a strict policy and has the potential to break an application since it blocks all cross-site navigations, including navigations through hyperlinks.&lt;/p>

 &lt;blockquote class="book-hint2 tip">
 &lt;p class="hint-title tip">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#tip-notice">&lt;/use>
 &lt;/svg>&lt;span>tip&lt;/span>&lt;/p>
 Instead of rejecting all cross-site interactions, the user could be prompted to confirm the action, e.g. &lt;em>Confirm that you visited this page from a trusted origin&lt;/em>, to mitigate the risk of attacks in the background, and, at the same time, help prevent unintended breakages of an application.
 &lt;/blockquote>


&lt;h2 id="implementation-with-fetch-metadata">
 Implementation with Fetch Metadata
 &lt;a class="anchor" href="#implementation-with-fetch-metadata">#&lt;/a>
&lt;/h2>
&lt;p>The below snippet showcases an example implementation of the Navigation Isolation Policy with the use of &lt;a href="https://xsleaks.dev/docs/defenses/opt-in/fetch-metadata/">Fetch Metadata&lt;/a> headers &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>:&lt;/p></description></item><item><title>Execution Timing</title><link>https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/</guid><description>&lt;p>Measuring the time of JavaScript execution in a browser can give attackers information on when certain events are triggered, and how long some operations take.&lt;/p>
&lt;h2 id="timing-the-event-loop">
 Timing the Event Loop
 &lt;a class="anchor" href="#timing-the-event-loop">#&lt;/a>
&lt;/h2>
&lt;p>JavaScript&amp;rsquo;s concurrency model is based on a &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">single-threaded event loop&lt;/a> which means it can only run one task at a time. If, for example, some time-consuming task blocks the event loop, the user can perceive a freeze on a page as a result of the UI thread being starved. Other tasks must wait until the blocking task finishes. Each browser implements different &lt;a href="https://chromium.googlesource.com/chromium/src/&amp;#43;/main/docs/process_model_and_site_isolation.md">process models&lt;/a>, which means some web sites might run in different threads (and event loops) depending on their relations.&lt;/p></description></item><item><title>Hybrid Timing</title><link>https://xsleaks.dev/docs/attacks/timing-attacks/hybrid-timing/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/timing-attacks/hybrid-timing/</guid><description>&lt;p>Hybrid Timing Attacks allow attackers to measure the sum of a group of factors that influence the final timing measurement. These factors include:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/">Network delays&lt;/a>&lt;/li>
&lt;li>Document parsing&lt;/li>
&lt;li>Retrieval and processing of subresources&lt;/li>
&lt;li>&lt;a href="https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/">Code execution&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Some of the factors differ in value depending on the application. This means that &lt;a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/">Network Timing&lt;/a> might be more significant for pages with more backend processing, while &lt;a href="https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/">Execution Timing&lt;/a> can be more significant in applications processing and displaying data within the browser. Attackers can also eliminate some of these factors to obtain more precise measurements. For example, an attacker could preload all of the subresources by embedding the page as an &lt;code>iframe&lt;/code> (forcing the browser to cache the subresources) and then perform a second measurement, which excludes any delay introduced by the retrieval of those subresources.&lt;/p></description></item><item><title>ID Attribute</title><link>https://xsleaks.dev/docs/attacks/id-attribute/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/id-attribute/</guid><description>&lt;p>The &lt;code>id&lt;/code> attribute is widely used to identify &lt;code>HTML&lt;/code> elements. Unfortunately, cross-origin websites can determine whether a given &lt;code>id&lt;/code> is set anywhere on a page by leveraging the &lt;code>focus&lt;/code> event and &lt;code>URL&lt;/code> fragments. If &lt;code>https://example.com/foo#bar&lt;/code> is loaded, the browser attempts to scroll to the element with &lt;code>id=&amp;quot;bar&amp;quot;&lt;/code>. This can be detected cross-origin by loading &lt;code>https://example.com/foo#bar&lt;/code> in an iframe; if there is an element with &lt;code>id=&amp;quot;bar&amp;quot;&lt;/code>, the &lt;code>focus&lt;/code> event fires. The &lt;code>blur&lt;/code> event can also be used for the same purpose &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>.&lt;/p></description></item><item><title>postMessage Broadcasts</title><link>https://xsleaks.dev/docs/attacks/postmessage-broadcasts/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/postmessage-broadcasts/</guid><description>&lt;p>Applications often use &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage">postMessage broadcasts&lt;/a> to share information with other origins. Using &lt;code>postMessage&lt;/code> can lead to two kinds of XS-Leaks:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Sharing sensitive messages with untrusted origins&lt;/p>
&lt;ul>
&lt;li>The &lt;code>postMessage&lt;/code> API supports a &lt;code>targetOrigin&lt;/code> parameter that can be used to restrict which origins can receive the message. If the message contains any sensitive data, it is important to use this parameter.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Leaking information based on varying content or on the presence of a broadcast&lt;/p></description></item><item><title>Strict Isolation Policy</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/strict-isolation/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/isolation-policies/strict-isolation/</guid><description>&lt;p>Strict Isolation Policy is intended to protect against all cross-site interactions (including navigations to the application through hyperlinks). This is a very strict policy that has the potential to prevent applications from functioning properly.&lt;/p>

 &lt;blockquote class="book-hint2 tip">
 &lt;p class="hint-title tip">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#tip-notice">&lt;/use>
 &lt;/svg>&lt;span>tip&lt;/span>&lt;/p>
 &lt;p>Instead of rejecting all cross-site interactions, the user could be prompted to confirm the action, e.g. &lt;em>Confirm that you visited this page from a trusted origin&lt;/em>, to mitigate the risk of attacks in the background, and, at the same time, help prevent unintended breakages of an application.&lt;/p></description></item><item><title>CSS Injection</title><link>https://xsleaks.dev/docs/attacks/css-injection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/css-injection/</guid><description>&lt;h2 id="css-injection">
 CSS Injection
 &lt;a class="anchor" href="#css-injection">#&lt;/a>
&lt;/h2>

 &lt;blockquote class="book-hint2 warning">
 &lt;p class="hint-title warning">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#warning-notice">&lt;/use>
 &lt;/svg>&lt;span>warning&lt;/span>&lt;/p>
 This group of XS-Leaks requires a CSS injection on the target page.
 &lt;/blockquote>


&lt;p>Among the different CSS injection vectors, the most noticeable one is the abuse of CSS Selectors. They can be used as an expression to match and select certain HTML elements. For example, the selector &lt;code>input[value^=&amp;quot;a&amp;quot;]&lt;/code> is matched if the value of an &lt;code>input&lt;/code> tag starts with the character &amp;ldquo;a&amp;rdquo;. So, to detect if a CSS Selector matches the expression, attackers can trigger a callback to one of their websites using certain properties like &lt;code>background&lt;/code>, &lt;code>@import&lt;/code>, etc. &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. The matching process can easily be brute-forced, and extended to the full string.&lt;/p></description></item><item><title>Download Bar</title><link>https://xsleaks.dev/docs/attacks/historical/download-bar/</link><pubDate>Tue, 23 Apr 2024 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/historical/download-bar/</guid><description>&lt;p>In Chromium-based browsers, when a file was downloaded, a preview of the download process appeared in a bar at the bottom, integrated into the browser window. By monitoring the window height, attackers could detect whether the &amp;ldquo;download bar&amp;rdquo; opened:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Read the current height of the window
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> screenHeight &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">window&lt;/span>.innerHeight;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Load the page that may or may not trigger the download
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">window&lt;/span>.open(&lt;span style="color:#f1fa8c">&amp;#39;https://example.org&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Wait for the tab to load
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>setTimeout(() =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// If the download bar appears, the height of all tabs will be smaller
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#8be9fd;font-style:italic">window&lt;/span>.innerHeight &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> screenHeight) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> console.log(&lt;span style="color:#f1fa8c">&amp;#39;Download bar detected&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> console.log(&lt;span style="color:#f1fa8c">&amp;#39;Download bar not detected&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}, &lt;span style="color:#bd93f9">2000&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
 &lt;blockquote class="book-hint2 important">
 &lt;p class="hint-title important">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#important-notice">&lt;/use>
 &lt;/svg>&lt;span>important&lt;/span>&lt;/p></description></item><item><title>Fetch Metadata</title><link>https://xsleaks.dev/docs/defenses/opt-in/fetch-metadata/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/fetch-metadata/</guid><description>&lt;p>&lt;a href="https://www.w3.org/TR/fetch-metadata/">Fetch Metadata Request Headers&lt;/a> are sent by browsers with HTTPS requests. These headers provide context on how a request was initiated so that applications are able to make more informed decisions on how to respond to them. This allows servers to behave differently when they detect potential attacks (e.g. unexpected cross-origin requests). This can be very effective against cross-origin attacks like XSSI, XS-Leaks, Clickjacking, and CSRF if a strict policy is deployed on the server.&lt;/p></description></item><item><title>Cache Protections</title><link>https://xsleaks.dev/docs/defenses/design-protections/cache-protections/</link><pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/design-protections/cache-protections/</guid><description>&lt;p>There are a number of different approaches applications can use to defend against cache probing-based XS-Leaks. These approaches are explained in the following sections.&lt;/p>
&lt;h1 id="cache-protection-via-cache-control-headers">
 Cache Protection via &lt;code>Cache-Control&lt;/code> Headers
 &lt;a class="anchor" href="#cache-protection-via-cache-control-headers">#&lt;/a>
&lt;/h1>
&lt;p>If it is acceptable to disable caching, doing so provides a strong defense against cache probing attacks. Disabling caching means that every time someone loads a resource, the resource has to be fetched again. To disable caching, set a &lt;code>Cache-Control: no-store&lt;/code> header on every single response that you wish to protect.&lt;/p></description></item><item><title>Connection Pool</title><link>https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/</guid><description>&lt;p>Another way to measure the network timing of a request consists of abusing the socket pool of a browser &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. Browsers use sockets to communicate with servers. As the operating system and the hardware it runs on have limited resources, browsers have to impose a limit. &lt;a href="https://xsinator.com/testing.html#WebSocket%20Leak%20%28GC%29">Run demo (Chrome)&lt;/a> &lt;a href="https://xsinator.com/testing.html#WebSocket%20Leak%20%28FF%29">Run demo (Firefox)&lt;/a>&lt;/p>
&lt;p>To exploit the existence of this limit, attackers can:&lt;/p>
&lt;ol>
&lt;li>Check what the limit of the browser is, for example 256 global sockets for TCP and 6000 global sockets for UDP. &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/li>
&lt;li>Block 
&lt;link rel="stylesheet" href="https://xsleaks.dev/katex/katex.min.css" />
&lt;script defer src="https://xsleaks.dev/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://xsleaks.dev/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \(255\)
&lt;/span>
 sockets for a long period of time by performing &lt;span>
 \(255\)
&lt;/span>
 requests to different hosts that simply hang the connection&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Client
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">for&lt;/span>(&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> i&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#bd93f9">0&lt;/span>; i&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>&lt;span style="color:#bd93f9">255&lt;/span>; i&lt;span style="color:#ff79c6">++&lt;/span>) fetch(&lt;span style="color:#f1fa8c">&amp;#39;https://&amp;#39;&lt;/span>&lt;span style="color:#ff79c6">+&lt;/span>i&lt;span style="color:#ff79c6">+&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;.example.com/&amp;#39;&lt;/span>, {mode&lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;no-cors&amp;#34;&lt;/span>, cache&lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;no-store&amp;#34;&lt;/span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># Server&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">from&lt;/span> http.server &lt;span style="color:#ff79c6">import&lt;/span> BaseHTTPRequestHandler, HTTPServer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> time
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">handler&lt;/span>(BaseHTTPRequestHandler):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">do_GET&lt;/span>(&lt;span style="font-style:italic">self&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time&lt;span style="color:#ff79c6">.&lt;/span>sleep(&lt;span style="color:#8be9fd;font-style:italic">float&lt;/span>(&lt;span style="color:#bd93f9">100000&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">self&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>send_response(&lt;span style="color:#bd93f9">200&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">self&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>send_header(&lt;span style="color:#f1fa8c">&amp;#39;Cache-Control&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;no-store&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">self&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>end_headers()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">with&lt;/span> HTTPServer((&lt;span style="color:#f1fa8c">&amp;#39;&amp;#39;&lt;/span>, &lt;span style="color:#bd93f9">8000&lt;/span>), handler) &lt;span style="color:#ff79c6">as&lt;/span> server:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server&lt;span style="color:#ff79c6">.&lt;/span>serve_forever()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>Use the &lt;span>
 \(256^{th}\)
&lt;/span>
 socket by performing a request to the target page.&lt;/li>
&lt;li>Perform a &lt;span>
 \(257^{th}\)
&lt;/span>
 request to another host. Since all the sockets are being used (in steps 2 and 3), this request must wait until the pool receives an available socket. This waiting period provides the attacker with the network timing of the &lt;span>
 \(256^{th}\)
&lt;/span>
 socket, which belongs to the target page. This works because the &lt;span>
 \(255\)
&lt;/span>
 sockets in step 2 are still blocked, so if the pool received an available socket, it was caused by the release of the socket in step 3. The time to release the &lt;span>
 \(256^{th}\)
&lt;/span>
 socket is directly connected with the time taken to complete the request.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>performance.clearResourceTimings();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">await&lt;/span> fetch(location.href, {cache&lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;no-store&amp;#34;&lt;/span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">await&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">Promise&lt;/span>(r =&amp;gt; setTimeout(r, &lt;span style="color:#bd93f9">1000&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> data &lt;span style="color:#ff79c6">=&lt;/span> performance.getEntries().pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> type &lt;span style="color:#ff79c6">=&lt;/span> (data.connectStart &lt;span style="color:#ff79c6">===&lt;/span> data.startTime) &lt;span style="color:#ff79c6">?&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;reused&amp;#39;&lt;/span> &lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;new&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>console.log(&lt;span style="color:#f1fa8c">&amp;#39;Time spent: &amp;#39;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> data.duration &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39; on &amp;#39;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> type &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39; connection.&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="connection-reuse">
 Connection reuse
 &lt;a class="anchor" href="#connection-reuse">#&lt;/a>
&lt;/h2>
&lt;p>With HTTP/1.1 (TCP) and HTTP/2 (TCP) and HTTP/3 (UDP) requests may reuse an existing connection for a host to improve performance. &lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>
HTTP/2 also has Connection Coalescing which allows different hostnames that are accessible from the same web server to reuse a connection. &lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>
This is currently keyed by if credentials are included in the request.
Since a reused connection is normally faster this could allow for detecting if a site has connected to a host excluding anything thatâ€™s been cached and leaking information about the cross-site request by abusing Stream prioritization and HPACK compression. &lt;sup id="fnref:7">&lt;a href="#fn:7" class="footnote-ref" role="doc-noteref">7&lt;/a>&lt;/sup>
Connections may get closed if they are left idle or the sockets are exhausted, for example 256 connections for HTTP/2 or 30 seconds idle for HTTP/3. &lt;sup id="fnref1:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;sup id="fnref:8">&lt;a href="#fn:8" class="footnote-ref" role="doc-noteref">8&lt;/a>&lt;/sup>
This may also leak when the connection happened and the browser can have per connection limits and on how many connections are allowed per host, for example 6 connections per host. &lt;sup id="fnref2:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p></description></item><item><title>Content-Type</title><link>https://xsleaks.dev/docs/attacks/historical/content-type/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/historical/content-type/</guid><description>&lt;p>Leaking the Content-Type of a request would provide attackers with a new way of distinguishing two requests from each other.&lt;/p>
&lt;h2 id="typemustmatch">
 typeMustMatch
 &lt;a class="anchor" href="#typemustmatch">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://web.archive.org/web/20210421092442/https://developer.mozilla.org/en-US/docs/Web/API/HTMLObjectElement/typeMustMatch">&lt;code>typeMustMatch&lt;/code>&lt;/a> is a Boolean that reflects the &lt;code>typeMustMatch&lt;/code> attribute of the &lt;code>object&lt;/code> element. It ensures that a certain MIME type must be enforced when loading an object, by verifying if the &lt;code>Content-Type&lt;/code> of the resource is the same as the one provided in the object. Unfortunately, this enforcement also allowed attackers to leak the &lt;code>Content-Type&lt;/code> and Status Codes returned by a website &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>.&lt;/p></description></item><item><title>Cross-Origin Read Blocking</title><link>https://xsleaks.dev/docs/defenses/secure-defaults/corb/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/secure-defaults/corb/</guid><description>&lt;p>Cross-Origin Read Blocking (CORB) is a security mechanism that prevents attackers from loading certain cross-origin resources &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. This protection was created to defend against speculative side-channel attacks such as Spectre that allow attackers to read the memory of the process that both cross-site pages (e.g. &lt;em>attacker.com&lt;/em> and &lt;em>sensitive.com&lt;/em>) were embedded into. CORB aims to prevent attackers from loading certain sensitive cross-origin resources into an attacker-controlled process. For example, if an attacker tries to load cross-origin HTML, XML, or JSON into an &lt;code>img&lt;/code> tag, CORB prevents this from happening. With CORB, the scenario is treated as though the server returned no data.&lt;/p></description></item><item><title>Cross-Origin-Opener-Policy</title><link>https://xsleaks.dev/docs/defenses/opt-in/coop/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/coop/</guid><description>&lt;p>Getting access to a website&amp;rsquo;s &lt;code>window&lt;/code> object is a common prerequisite for different XS-Leak techniques. &lt;a href="https://xsleaks.dev/docs/defenses/opt-in/xfo/">Framing Protections&lt;/a> can ensure that an attacker cannot use iframes to access the &lt;code>window&lt;/code> object, but this does not stop an attacker from accessing the &lt;code>window&lt;/code> object from an opened window through &lt;code>window.open(url)&lt;/code> or &lt;code>window.opener&lt;/code> references.&lt;/p>
&lt;p>Exploiting XS-Leaks with &lt;code>window.open&lt;/code> is generally seen as the least appealing option for an attacker because the user can see it happen in the open browser window. However, it&amp;rsquo;s usually the right technique when:&lt;/p></description></item><item><title>Cross-Origin-Resource-Policy</title><link>https://xsleaks.dev/docs/defenses/opt-in/corp/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/corp/</guid><description>&lt;p>Cross-Origin Resource Policy (CORP) is a web platform security feature that allows websites to prevent certain resources from being loaded by other origins. This protection complements CORB since it is an opt-in defense, whereas CORB blocks some cross-origin reads by default. CORP is designed to protect against both speculative execution attacks and XS-Leaks by allowing developers to ensure that sensitive resources cannot end up in attacker-controlled processes. Unlike CORB, this protection is enforced in the browser only if an application opts in to the protection. Applications can define which groups of origins (&amp;lsquo;same-site&amp;rsquo;, &amp;lsquo;same-origin&amp;rsquo;, &amp;lsquo;cross-site&amp;rsquo;) are allowed to read their resources.&lt;/p></description></item><item><title>Framing Protections</title><link>https://xsleaks.dev/docs/defenses/opt-in/xfo/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/xfo/</guid><description>&lt;p>A considerable number of XS-Leaks rely on some of the properties of iframes. If an attacker is unable to embed the contents of a page as an &lt;code>iframe&lt;/code>, &lt;code>frame&lt;/code>, &lt;code>embed&lt;/code> or &lt;code>object&lt;/code>, then the attack may no longer be possible. To mitigate XS-Leaks which rely on these objects, pages can forbid or select which origins can embed them. Doing so is possible by using the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options">&lt;code>X-Frame-Options&lt;/code> header&lt;/a> or the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors">CSP frame-ancestors directive&lt;/a>.&lt;/p></description></item><item><title>Partitioned HTTP Cache</title><link>https://xsleaks.dev/docs/defenses/secure-defaults/partitioned-cache/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/secure-defaults/partitioned-cache/</guid><description>&lt;p>In order to defend against cache probing attacks, browser developers are actively working on implementing a partitioned HTTP cache functionality that would in essence ensure each website has a distinct cache. Since cache probing relies on the fact that a browser&amp;rsquo;s HTTP cache is shared across every website, a partitioned HTTP cache can defend against many cache probing techniques. This is done by using tuples (either &lt;code>(top-frame-site, resource-url)&lt;/code> like firefox &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> or &lt;code>(top-frame-site, framing-site, resource-url)&lt;/code>) like chromium/chrome &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> as the cache keys to ensure the cache is partitioned by the requesting site. This makes it more challenging for attackers to interact with the cached contents of different sites &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> &lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> &lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>. Safari currently ships a partitioned cache &lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>.&lt;/p></description></item><item><title>Portals</title><link>https://xsleaks.dev/docs/attacks/experiments/portals/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/experiments/portals/</guid><description>&lt;p>&lt;a href="https://web.dev/hands-on-portals/">Portals&lt;/a> are a new feature of the web which is similar to &lt;code>iframes&lt;/code>, but with more emphasis on speed and user experience. The &lt;a href="https://web.dev/hands-on-portals/">&lt;code>portal&lt;/code>&lt;/a> element is only available on Chromium-based browsers under a preference flag. The corresponding &lt;a href="https://wicg.github.io/portals/">specification&lt;/a> is still under active discussion.&lt;/p>
&lt;p>Unfortunately, research of this new feature has discovered some critical issues, including new XS-Leaks &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>.&lt;/p>
&lt;h2 id="id-leaks">
 ID Leaks
 &lt;a class="anchor" href="#id-leaks">#&lt;/a>
&lt;/h2>
&lt;p>Portals can be abused as an alternative to the &lt;a href="https://xsleaks.dev/docs/attacks/id-attribute/">ID Attribute XS-Leak&lt;/a>. If a website sets &lt;a href="https://xsleaks.dev/docs/defenses/opt-in/xfo/">framing protections&lt;/a>, the same technique can be applied using the &lt;code>portal&lt;/code> element instead &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>.&lt;/p></description></item><item><title>SameSite Cookies</title><link>https://xsleaks.dev/docs/defenses/opt-in/same-site-cookies/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/same-site-cookies/</guid><description>&lt;p>SameSite cookies are one of the most impactful modern security mechanisms for fixing security issues that involve cross-site requests. This mechanism allows applications to force browsers to only include cookies in requests that are issued same-site &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. This type of cookie has three modes: &lt;code>None&lt;/code>, &lt;code>Lax&lt;/code>, and &lt;code>Strict&lt;/code>.&lt;/p>
&lt;h2 id="samesite-cookie-modes">
 SameSite Cookie Modes
 &lt;a class="anchor" href="#samesite-cookie-modes">#&lt;/a>
&lt;/h2>
&lt;p>The following SameSite cookie modes are available:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>None&lt;/code> â€“ Disables all protections and restores the old behavior of cookies. This mode is not recommended.&lt;/p></description></item><item><title>Scroll to Text Fragment</title><link>https://xsleaks.dev/docs/attacks/experiments/scroll-to-text-fragment/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/experiments/scroll-to-text-fragment/</guid><description>&lt;p>Scroll to Text Fragment (STTF) is a new web platform feature that allows users to create a link to any part of a web page text. The fragment &lt;code>#:~:text=&lt;/code> carries a text snippet that is highlighted and brought into the viewport by the browser. This feature can introduce a new XS-Leak if attackers are able to detect when this behavior occurs. This issue is very similar to the &lt;a href="https://docs.google.com/document/d/15HVLD6nddA0OaI8Dd0ayBP2jlGw5JpRD-njAyY1oNZo/edit#heading=h.wds2qckm3kh5">Scroll to CSS Selector&lt;/a> XS-Leak.&lt;/p></description></item><item><title>Stateful Browser Features</title><link>https://xsleaks.dev/docs/attacks/historical/stateful-browser-features/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/historical/stateful-browser-features/</guid><description>&lt;p>Some browser features/extensions change the way requests are processed, depending on certain website states generated by the browser. Attackers can sometimes observe the whole process and mess with the browser, triggering actions that produce side effects on those states.&lt;/p>
&lt;h2 id="webkit--itp">
 WebKit â€“ ITP
 &lt;a class="anchor" href="#webkit--itp">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://webkit.org/tracking-prevention/">Intelligent Tracking Prevention&lt;/a> (ITP) is a privacy feature which is part of &lt;a href="https://webkit.org/tracking-prevention/">WebKit Tracking Prevention technologies&lt;/a>. It&amp;rsquo;s a conjunction of several features and aims to prevent a website from tracking a user under a third-party context. Unfortunately, the initial design introduced a new XS-Leak &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>, allowing attackers to abuse the states implicitly created by ITP to classify websites as trackers.&lt;/p></description></item><item><title>Subresource Protections</title><link>https://xsleaks.dev/docs/defenses/design-protections/subresource-protections/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/design-protections/subresource-protections/</guid><description>&lt;p>The fundamental idea behind designing protections for subresources is that subresources cannot be targeted by XS-Leaks if the attacker cannot make them return any user data. If implemented correctly, this approach can be a very strong defense, though it is likely to be tough to implement and could negatively impact the user experience.&lt;/p>

 &lt;blockquote class="book-hint2 tip">
 &lt;p class="hint-title tip">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#tip-notice">&lt;/use>
 &lt;/svg>&lt;span>tip&lt;/span>&lt;/p>
 It can be very effective to deploy this approach on any specific resources that are known to be especially sensitive to XS-Leaks. But, due to the challenges of deploying this protection universally, applications are encouraged to deploy &lt;a href="https://xsleaks.dev/docs/defenses/">opt-in web platform security features&lt;/a> as the default approach.
 &lt;/blockquote>


&lt;h2 id="token-based-protections">
 Token-Based Protections
 &lt;a class="anchor" href="#token-based-protections">#&lt;/a>
&lt;/h2>
&lt;p>A strong protection for subresources can be achieved by including a user-specific token in every request. This protects against most XS-Leak techniques if implemented correctly. The idea is that in order to verify a request for a resource as being legitimate, a token must be included. This token must be provided to the client in a way that prevents an attacker from including it in their own requests.&lt;/p></description></item><item><title>Document Policies</title><link>https://xsleaks.dev/docs/defenses/opt-in/document-policies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/document-policies/</guid><description>&lt;p>&lt;code>Document-Policy&lt;/code> is an experimental mechanism, similar to another experimental Feature Policy &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>, used to cover features which are more about configuring a document, or removing features (sandboxing) from a document or a frame. &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> It can be for example set in a header response as shown in the example below.&lt;/p>

 &lt;blockquote class="book-hint2 example">
 &lt;p class="hint-title example">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#example-notice">&lt;/use>
 &lt;/svg>&lt;span>example&lt;/span>&lt;/p>
 Document-Policy: unsized-media=?0, document-write=?0, max-image-bpp=2.0, frame-loading=lazy
 &lt;/blockquote>


&lt;h1 id="forceloadattop">
 ForceLoadAtTop
 &lt;a class="anchor" href="#forceloadattop">#&lt;/a>
&lt;/h1>
&lt;p>The ForceLoadAtTop feature provides an opt-out for &lt;a href="https://xsleaks.dev/docs/attacks/experiments/scroll-to-text-fragment/">Scroll To Text&lt;/a> (and other load-on-scroll behaviors) for privacy sensitive sites. The feature allows sites to indicate that they should always be loaded at the top of the page, blocking any scroll-on-load behaviors including text fragments and element fragments. It can be set via &lt;code>Document-Policy: force-load-at-top&lt;/code> response header.&lt;/p></description></item></channel></rss>