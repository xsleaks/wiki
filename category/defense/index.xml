<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Defense on XS-Leaks Wiki</title><link>https://xsleaks.dev/category/defense/</link><description>Recent content in Defense on XS-Leaks Wiki</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 21 Apr 2024 20:35:32 +0100</lastBuildDate><atom:link href="https://xsleaks.dev/category/defense/index.xml" rel="self" type="application/rss+xml"/><item><title>Resource Isolation Policy</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/resource-isolation/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/isolation-policies/resource-isolation/</guid><description>&lt;p>Resource Isolation Policy prevents external websites from requesting your resources. Blocking such traffic mitigates common web vulnerabilities such as CSRF, XSSI, or XS-Leaks. The policy can be enabled for applications whose endpoints are not intended to be loaded in a cross-site context and will allow resource requests coming from your application as well as direct navigations.&lt;/p>
&lt;h2 id="implementation-with-fetch-metadata">
 Implementation with Fetch Metadata
 &lt;a class="anchor" href="#implementation-with-fetch-metadata">#&lt;/a>
&lt;/h2>
&lt;p>The below snippet showcases an example implementation of the Resource Isolation Policy with the use of &lt;a href="https://xsleaks.dev/docs/defenses/opt-in/fetch-metadata/">Fetch Metadata&lt;/a> headers:&lt;/p></description></item><item><title>Framing Isolation Policy</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/framing-isolation/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/isolation-policies/framing-isolation/</guid><description>&lt;p>Framing Isolation Policy is a stricter version of &lt;a href="https://xsleaks.dev/docs/defenses/opt-in/xfo/">Framing Protections&lt;/a> where the request gets blocked at the application level rather than by the browser. This is designed to protect against various attacks (e.g. XSSI, CSRF, XS-Leaks) by blocking framing requests to endpoints that are not intended to be framable.&lt;/p>
&lt;p>It can be combined with &lt;a href="https://xsleaks.dev/docs/defenses/isolation-policies/resource-isolation/">Resource Isolation Policy&lt;/a> to effectively tighten the attack surface within cross-site information leaks.&lt;/p>

 &lt;blockquote class="book-hint2 tip">
 &lt;p class="hint-title tip">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#tip-notice">&lt;/use>
 &lt;/svg>&lt;span>tip&lt;/span>&lt;/p>
 Instead of rejecting all non-framable endpoints, the user could be prompted to confirm the action, e.g. &lt;em>Confirm that you visited this page from a trusted origin&lt;/em>, to mitigate the risk of attacks in the background, and, at the same time, help prevent unintended breakages of an application.
 &lt;/blockquote>



 &lt;blockquote class="book-hint2 tip">
 &lt;p class="hint-title tip">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#tip-notice">&lt;/use>
 &lt;/svg>&lt;span>tip&lt;/span>&lt;/p></description></item><item><title>Navigation Isolation Policy</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/navigation-isolation/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/isolation-policies/navigation-isolation/</guid><description>&lt;p>Navigation Isolation Policy is a server-side protection mechanism intended to mitigate CSRF, clickjacking, reflected XSS, and XS-Leaks that make use of cross-site window contexts. This is a strict policy and has the potential to break an application since it blocks all cross-site navigations, including navigations through hyperlinks.&lt;/p>

 &lt;blockquote class="book-hint2 tip">
 &lt;p class="hint-title tip">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#tip-notice">&lt;/use>
 &lt;/svg>&lt;span>tip&lt;/span>&lt;/p>
 Instead of rejecting all cross-site interactions, the user could be prompted to confirm the action, e.g. &lt;em>Confirm that you visited this page from a trusted origin&lt;/em>, to mitigate the risk of attacks in the background, and, at the same time, help prevent unintended breakages of an application.
 &lt;/blockquote>


&lt;h2 id="implementation-with-fetch-metadata">
 Implementation with Fetch Metadata
 &lt;a class="anchor" href="#implementation-with-fetch-metadata">#&lt;/a>
&lt;/h2>
&lt;p>The below snippet showcases an example implementation of the Navigation Isolation Policy with the use of &lt;a href="https://xsleaks.dev/docs/defenses/opt-in/fetch-metadata/">Fetch Metadata&lt;/a> headers &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>:&lt;/p></description></item><item><title>Strict Isolation Policy</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/strict-isolation/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/isolation-policies/strict-isolation/</guid><description>&lt;p>Strict Isolation Policy is intended to protect against all cross-site interactions (including navigations to the application through hyperlinks). This is a very strict policy that has the potential to prevent applications from functioning properly.&lt;/p>

 &lt;blockquote class="book-hint2 tip">
 &lt;p class="hint-title tip">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#tip-notice">&lt;/use>
 &lt;/svg>&lt;span>tip&lt;/span>&lt;/p>
 &lt;p>Instead of rejecting all cross-site interactions, the user could be prompted to confirm the action, e.g. &lt;em>Confirm that you visited this page from a trusted origin&lt;/em>, to mitigate the risk of attacks in the background, and, at the same time, help prevent unintended breakages of an application.&lt;/p></description></item><item><title>Fetch Metadata</title><link>https://xsleaks.dev/docs/defenses/opt-in/fetch-metadata/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/fetch-metadata/</guid><description>&lt;p>&lt;a href="https://www.w3.org/TR/fetch-metadata/">Fetch Metadata Request Headers&lt;/a> are sent by browsers with HTTPS requests. These headers provide context on how a request was initiated so that applications are able to make more informed decisions on how to respond to them. This allows servers to behave differently when they detect potential attacks (e.g. unexpected cross-origin requests)[^1]. This can be very effective against cross-origin attacks like XSSI, XS-Leaks, Clickjacking, and CSRF if a strict policy is deployed on the server.&lt;/p></description></item><item><title>Cache Protections</title><link>https://xsleaks.dev/docs/defenses/design-protections/cache-protections/</link><pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/design-protections/cache-protections/</guid><description>&lt;p>There are a number of different approaches applications can use to defend against cache probing-based XS-Leaks. These approaches are explained in the following sections.&lt;/p>
&lt;h1 id="cache-protection-via-cache-control-headers">
 Cache Protection via &lt;code>Cache-Control&lt;/code> Headers
 &lt;a class="anchor" href="#cache-protection-via-cache-control-headers">#&lt;/a>
&lt;/h1>
&lt;p>If it is acceptable to disable caching, doing so provides a strong defense against cache probing attacks. Disabling caching means that every time someone loads a resource, the resource has to be fetched again. To disable caching, set a &lt;code>Cache-Control: no-store&lt;/code> header on every single response that you wish to protect.&lt;/p></description></item><item><title>Cross-Origin Read Blocking</title><link>https://xsleaks.dev/docs/defenses/secure-defaults/corb/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/secure-defaults/corb/</guid><description>&lt;p>Cross-Origin Read Blocking (CORB) is a security mechanism that prevents attackers from loading certain cross-origin resources &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. This protection was created to defend against speculative side-channel attacks such as Spectre that allow attackers to read the memory of the process that both cross-site pages (e.g. &lt;em>attacker.com&lt;/em> and &lt;em>sensitive.com&lt;/em>) were embedded into. CORB aims to prevent attackers from loading certain sensitive cross-origin resources into an attacker-controlled process. For example, if an attacker tries to load cross-origin HTML, XML, or JSON into an &lt;code>img&lt;/code> tag, CORB prevents this from happening. With CORB, the scenario is treated as though the server returned no data.&lt;/p></description></item><item><title>Cross-Origin-Opener-Policy</title><link>https://xsleaks.dev/docs/defenses/opt-in/coop/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/coop/</guid><description>&lt;p>Getting access to a website&amp;rsquo;s &lt;code>window&lt;/code> object is a common prerequisite for different XS-Leak techniques. &lt;a href="https://xsleaks.dev/docs/defenses/opt-in/xfo/">Framing Protections&lt;/a> can ensure that an attacker cannot use iframes to access the &lt;code>window&lt;/code> object, but this does not stop an attacker from accessing the &lt;code>window&lt;/code> object from an opened window through &lt;code>window.open(url)&lt;/code> or &lt;code>window.opener&lt;/code> references.&lt;/p>
&lt;p>Exploiting XS-Leaks with &lt;code>window.open&lt;/code> is generally seen as the least appealing option for an attacker because the user can see it happen in the open browser window. However, it&amp;rsquo;s usually the right technique when:&lt;/p></description></item><item><title>Cross-Origin-Resource-Policy</title><link>https://xsleaks.dev/docs/defenses/opt-in/corp/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/corp/</guid><description>&lt;p>Cross-Origin Resource Policy (CORP) is a web platform security feature that allows websites to prevent certain resources from being loaded by other origins. This protection complements CORB since it is an opt-in defense, whereas CORB blocks some cross-origin reads by default. CORP is designed to protect against both speculative execution attacks and XS-Leaks by allowing developers to ensure that sensitive resources cannot end up in attacker-controlled processes. Unlike CORB, this protection is enforced in the browser only if an application opts in to the protection. Applications can define which groups of origins (&amp;lsquo;same-site&amp;rsquo;, &amp;lsquo;same-origin&amp;rsquo;, &amp;lsquo;cross-site&amp;rsquo;) are allowed to read their resources.&lt;/p></description></item><item><title>Framing Protections</title><link>https://xsleaks.dev/docs/defenses/opt-in/xfo/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/xfo/</guid><description>&lt;p>A considerable number of XS-Leaks rely on some of the properties of iframes. If an attacker is unable to embed the contents of a page as an &lt;code>iframe&lt;/code>, &lt;code>frame&lt;/code>, &lt;code>embed&lt;/code> or &lt;code>object&lt;/code>, then the attack may no longer be possible. To mitigate XS-Leaks which rely on these objects, pages can forbid or select which origins can embed them. Doing so is possible by using the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options">&lt;code>X-Frame-Options&lt;/code> header&lt;/a> or the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors">CSP frame-ancestors directive&lt;/a>.&lt;/p></description></item><item><title>Partitioned HTTP Cache</title><link>https://xsleaks.dev/docs/defenses/secure-defaults/partitioned-cache/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/secure-defaults/partitioned-cache/</guid><description>&lt;p>In order to defend against cache probing attacks, browser developers are actively working on implementing a partitioned HTTP cache functionality that would in essence ensure each website has a distinct cache. Since cache probing relies on the fact that a browser&amp;rsquo;s HTTP cache is shared across every website, a partitioned HTTP cache can defend against many cache probing techniques. This is done by using tuples (either &lt;code>(top-frame-site, resource-url)&lt;/code> like firefox &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> or &lt;code>(top-frame-site, framing-site, resource-url)&lt;/code>) like chromium/chrome &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> as the cache keys to ensure the cache is partitioned by the requesting site. This makes it more challenging for attackers to interact with the cached contents of different sites &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> &lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> &lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>. Safari currently ships a partitioned cache &lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>.&lt;/p></description></item><item><title>SameSite Cookies</title><link>https://xsleaks.dev/docs/defenses/opt-in/same-site-cookies/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/same-site-cookies/</guid><description>&lt;p>SameSite cookies are one of the most impactful modern security mechanisms for fixing security issues that involve cross-site requests. This mechanism allows applications to force browsers to only include cookies in requests that are issued same-site &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. This type of cookie has three modes: &lt;code>None&lt;/code>, &lt;code>Lax&lt;/code>, and &lt;code>Strict&lt;/code>.&lt;/p>
&lt;h2 id="samesite-cookie-modes">
 SameSite Cookie Modes
 &lt;a class="anchor" href="#samesite-cookie-modes">#&lt;/a>
&lt;/h2>
&lt;p>The following SameSite cookie modes are available:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>None&lt;/code> â€“ Disables all protections and restores the old behavior of cookies. This mode is not recommended.&lt;/p></description></item><item><title>Subresource Protections</title><link>https://xsleaks.dev/docs/defenses/design-protections/subresource-protections/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/design-protections/subresource-protections/</guid><description>&lt;p>The fundamental idea behind designing protections for subresources is that subresources cannot be targeted by XS-Leaks if the attacker cannot make them return any user data. If implemented correctly, this approach can be a very strong defense, though it is likely to be tough to implement and could negatively impact the user experience.&lt;/p>

 &lt;blockquote class="book-hint2 tip">
 &lt;p class="hint-title tip">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#tip-notice">&lt;/use>
 &lt;/svg>&lt;span>tip&lt;/span>&lt;/p>
 It can be very effective to deploy this approach on any specific resources that are known to be especially sensitive to XS-Leaks. But, due to the challenges of deploying this protection universally, applications are encouraged to deploy &lt;a href="https://xsleaks.dev/docs/defenses/">opt-in web platform security features&lt;/a> as the default approach.
 &lt;/blockquote>


&lt;h2 id="token-based-protections">
 Token-Based Protections
 &lt;a class="anchor" href="#token-based-protections">#&lt;/a>
&lt;/h2>
&lt;p>A strong protection for subresources can be achieved by including a user-specific token in every request. This protects against most XS-Leak techniques if implemented correctly. The idea is that in order to verify a request for a resource as being legitimate, a token must be included. This token must be provided to the client in a way that prevents an attacker from including it in their own requests.&lt;/p></description></item><item><title>Document Policies</title><link>https://xsleaks.dev/docs/defenses/opt-in/document-policies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/opt-in/document-policies/</guid><description>&lt;p>&lt;code>Document-Policy&lt;/code> is an experimental mechanism, similar to another experimental Feature Policy &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>, used to cover features which are more about configuring a document, or removing features (sandboxing) from a document or a frame. &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> It can be for example set in a header response as shown in the example below.&lt;/p>

 &lt;blockquote class="book-hint2 example">
 &lt;p class="hint-title example">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#example-notice">&lt;/use>
 &lt;/svg>&lt;span>example&lt;/span>&lt;/p>
 Document-Policy: unsized-media=?0, document-write=?0, max-image-bpp=2.0, frame-loading=lazy
 &lt;/blockquote>


&lt;h1 id="forceloadattop">
 ForceLoadAtTop
 &lt;a class="anchor" href="#forceloadattop">#&lt;/a>
&lt;/h1>
&lt;p>The ForceLoadAtTop feature provides an opt-out for &lt;a href="https://xsleaks.dev/docs/attacks/experiments/scroll-to-text-fragment/">Scroll To Text&lt;/a> (and other load-on-scroll behaviors) for privacy sensitive sites. The feature allows sites to indicate that they should always be loaded at the top of the page, blocking any scroll-on-load behaviors including text fragments and element fragments. It can be set via &lt;code>Document-Policy: force-load-at-top&lt;/code> response header.&lt;/p></description></item></channel></rss>