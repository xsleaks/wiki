<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Attacks on XS-Leaks Wiki</title><link>https://xsleaks.dev/docs/attacks/</link><description>Recent content in Attacks on XS-Leaks Wiki</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://xsleaks.dev/docs/attacks/index.xml" rel="self" type="application/rss+xml"/><item><title>XS-Search</title><link>https://xsleaks.dev/docs/attacks/xs-search/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/xs-search/</guid><description>&lt;p>Cross-site search (XS-Search) is an important attack principle in the family of XS-Leaks. This type of attack abuses Query-Based Search Systems to leak user information from an attacker origin &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. The original attack uses timing measurements to detect whether or not a search system returns results and works as follows:&lt;/p>
&lt;ol>
&lt;li>Establish a baseline of the time needed for a request to return results (hit), and a baseline for the time needed by a request with no results (miss).&lt;/li>
&lt;li>Start a &lt;a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/">timing attack&lt;/a> on the request to the search endpoint, brute-forcing the first character (&lt;code>?q=r&lt;/code>).&lt;/li>
&lt;li>If the measurement is under the hit baseline, then add one more character (&lt;code>?q=ra&lt;/code>); otherwise try a new one (&lt;code>?q=s&lt;/code>).&lt;/li>
&lt;li>In the end, a full secret (&lt;code>?q=secret&lt;/code>) can be leaked.&lt;/li>
&lt;/ol>
&lt;p>This attack requires multiple timing measurements to be accurate, something which can be improved with inflation techniques and statistical analysis. Furthermore, instead of brute-forcing letter by letter, attackers can search specific words or sentences to leak only the occurrence of results.&lt;/p></description></item><item><title>Window References</title><link>https://xsleaks.dev/docs/attacks/window-references/</link><pubDate>Thu, 08 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/window-references/</guid><description>&lt;p>If a page sets its &lt;code>opener&lt;/code> property to &lt;code>null&lt;/code> or is using &lt;a href="https://xsleaks.dev/docs/defenses/opt-in/coop/">COOP&lt;/a> protection depending on the users&amp;rsquo; state, it becomes possible to infer cross-site information about that state. For example, attackers can detect whether a user is logged in by opening an endpoint in an iframe (or a new window) which only authenticated users have access to, simply by checking its window reference. &lt;a href="https://xsinator.com/testing.html#COOP%20Leak">Run demo&lt;/a>&lt;/p>
&lt;h2 id="code-snippet">
 Code Snippet
 &lt;a class="anchor" href="#code-snippet">#&lt;/a>
&lt;/h2>
&lt;p>The below snippet demonstrates how to detect whether the &lt;code>opener&lt;/code> property was set to &lt;code>null&lt;/code>, or whether the &lt;a href="https://xsleaks.dev/docs/defenses/opt-in/coop/">COOP&lt;/a> header is present with a value other than &lt;code>unsafe-none&lt;/code>. This can be done with both iframes and new windows.&lt;/p></description></item><item><title>CSS Tricks</title><link>https://xsleaks.dev/docs/attacks/css-tricks/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/css-tricks/</guid><description>&lt;h2 id="css-tricks">
 CSS Tricks
 &lt;a class="anchor" href="#css-tricks">#&lt;/a>
&lt;/h2>
&lt;p>CSS can be used to trick a user into exposing information such as embedded pixel values by making visual changes that are affected by the embed.&lt;/p>
&lt;h2 id="retrieving-users-history">
 Retrieving user&amp;rsquo;s history
 &lt;a class="anchor" href="#retrieving-users-history">#&lt;/a>
&lt;/h2>
&lt;p>Using the CSS &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:visited">&lt;code>:visited&lt;/code>&lt;/a> selector, itâ€™s possible to apply a different style for URLs that have been visited.&lt;br>
Previously it was possible to use &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle">&lt;code>getComputedStyle()&lt;/code>&lt;/a> to detect this difference, but now browsers prevent this by always returning values as if the link was visited and limiting what styles can be applied using the selector. &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;br>
So, it may be needed to trick the user into clicking an area that the CSS has affected.
This can be done using &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode">&lt;code>mix-blend-mode&lt;/code>&lt;/a>. &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;br>
There are also ways to do it without user interaction such as by abusing render timings.
This works because it takes time to paint links in a different color. &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;br>
A Proof of Concept to this attack can be found in a Chromium report &lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> and it works by having multiple links to increase the time difference.&lt;/p></description></item><item><title>Error Events</title><link>https://xsleaks.dev/docs/attacks/error-events/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/error-events/</guid><description>&lt;p>When a webpage issues a request to a server (e.g. fetch, HTML tags), the server receives and processes this request. When received, the server decides whether the request should succeed (e.g. 200) or fail (e.g. 404) based on the provided context. When a response has an error status, an &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/error_event">error event&lt;/a> is fired by the browser for the page to handle. These errors also cover situations where the parser fails, for example when trying to embed &lt;code>HTML&lt;/code> content as an image.&lt;/p></description></item><item><title>Frame Counting</title><link>https://xsleaks.dev/docs/attacks/frame-counting/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/frame-counting/</guid><description>&lt;p>Window references allow cross-origin pages to get access to some of the attributes of other pages. These references become available when using or allowing &lt;code>iframe&lt;/code> and &lt;code>window.open&lt;/code>. The references provide (limited) information about the window as they still respect the same-origin policy.&lt;/p>
&lt;p>One of the accessible attributes is &lt;code>window.length&lt;/code> which provides the number of frames in the window. This attribute can provide valuable information about a page to an attacker.&lt;/p></description></item><item><title>Navigations</title><link>https://xsleaks.dev/docs/attacks/navigations/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/navigations/</guid><description>&lt;p>Detecting if a cross-site page triggered a navigation (or didn&amp;rsquo;t) can be useful to an attacker. For example, a website may trigger a navigation in a certain endpoint &lt;a href="#case-scenarios">depending on the status of the user&lt;/a>.&lt;/p>
&lt;p>To detect if any kind of navigation occurred, an attacker can:&lt;/p>
&lt;ul>
&lt;li>Use an &lt;code>iframe&lt;/code> and count the number of times the &lt;code>onload&lt;/code> event is triggered.&lt;/li>
&lt;li>Check the value of &lt;code>history.length&lt;/code>, which is accessible through any window reference. This provides the number of entries in the history of a victim that were either changed by &lt;code>history.pushState&lt;/code> or by regular navigations. To get the value of &lt;code>history.length&lt;/code>, an attacker changes the location of the window reference to the target website, then changes back to same-origin, and finally reads the value. &lt;a href="https://xsinator.com/testing.html#History%20Length%20Leak">Run demo&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="download-trigger">
 Download Trigger
 &lt;a class="anchor" href="#download-trigger">#&lt;/a>
&lt;/h2>
&lt;p>When an endpoint sets the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition">&lt;code>Content-Disposition: attachment&lt;/code>&lt;/a> header, it instructs the browser to download the response as an attachment instead of navigating to it. Detecting if this behavior occurred might allow attackers to leak private information if the outcome depends on the state of the victim&amp;rsquo;s account.&lt;/p></description></item><item><title>Cache Probing</title><link>https://xsleaks.dev/docs/attacks/cache-probing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/cache-probing/</guid><description>&lt;p>The principle of Cache Probing consists of detecting whether a resource was cached by the browser. The concept has been known since the beginning of the web &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> and initially relied on detecting timing differences.&lt;/p>
&lt;p>When a user visits a website, some resources such as images, scripts, and HTML content are fetched and later cached by the browser (under certain conditions). This optimization makes future navigations faster as the browser serves those resources from disk instead of requesting them again. If an attacker can detect which resources are cached, this information can be enough to leak whether a user accessed a specific page in the past.&lt;/p></description></item><item><title>Element leaks</title><link>https://xsleaks.dev/docs/attacks/element-leaks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/element-leaks/</guid><description>&lt;p>Some HTML Elements might be used to leak a portion of data to a cross-origin page.
For example, the below media resources can leak information about its size, duration, type.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement">HTMLMediaElement&lt;/a> leaks the media &lt;code>duration&lt;/code> and the &lt;code>buffered&lt;/code> times. &lt;a href="https://xsinator.com/testing.html#Media%20Duration%20Leak">Run demo&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement">HTMLVideoElement&lt;/a> leaks the &lt;code>videoHeight&lt;/code> and &lt;code>videoWidth&lt;/code>
some browsers may also have &lt;code>webkitVideoDecodedByteCount&lt;/code>, &lt;code>webkitAudioDecodedByteCount&lt;/code> and &lt;code>webkitDecodedFrameCount&lt;/code>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality">getVideoPlaybackQuality()&lt;/a> leaks the &lt;code>totalVideoFrames&lt;/code>.&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement">HTMLImageElement&lt;/a> leaks the &lt;code>height&lt;/code> and &lt;code>width&lt;/code> but if the image is invalid they will be 0
and &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode">&lt;code>image.decode()&lt;/code>&lt;/a> will get rejected. &lt;a href="https://xsinator.com/testing.html#Media%20Dimensions%20Leak">Run demo&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>It&amp;rsquo;s possible to differentiate between media types via unique property for a given media type. For example, it is &lt;code>videoWidth&lt;/code> for a &lt;code>&amp;lt;video&amp;gt;&lt;/code>, or &lt;code>duration&lt;/code> for an &lt;code>&amp;lt;audio&amp;gt;&lt;/code>. The below snippet shows an example code that returns the type of a resource.&lt;/p></description></item><item><title>ID Attribute</title><link>https://xsleaks.dev/docs/attacks/id-attribute/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/id-attribute/</guid><description>&lt;p>The &lt;code>id&lt;/code> attribute is widely used to identify &lt;code>HTML&lt;/code> elements. Unfortunately, cross-origin websites can determine whether a given &lt;code>id&lt;/code> is set anywhere on a page by leveraging the &lt;code>focus&lt;/code> event and &lt;code>URL&lt;/code> fragments. If &lt;code>https://example.com/foo#bar&lt;/code> is loaded, the browser attempts to scroll to the element with &lt;code>id=&amp;quot;bar&amp;quot;&lt;/code>. This can be detected cross-origin by loading &lt;code>https://example.com/foo#bar&lt;/code> in an iframe; if there is an element with &lt;code>id=&amp;quot;bar&amp;quot;&lt;/code>, the &lt;code>focus&lt;/code> event fires. The &lt;code>blur&lt;/code> event can also be used for the same purpose &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>.&lt;/p></description></item><item><title>postMessage Broadcasts</title><link>https://xsleaks.dev/docs/attacks/postmessage-broadcasts/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/postmessage-broadcasts/</guid><description>&lt;p>Applications often use &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage">postMessage broadcasts&lt;/a> to share information with other origins. Using &lt;code>postMessage&lt;/code> can lead to two kinds of XS-Leaks:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Sharing sensitive messages with untrusted origins&lt;/p>
&lt;ul>
&lt;li>The &lt;code>postMessage&lt;/code> API supports a &lt;code>targetOrigin&lt;/code> parameter that can be used to restrict which origins can receive the message. If the message contains any sensitive data, it is important to use this parameter.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Leaking information based on varying content or on the presence of a broadcast&lt;/p></description></item><item><title>CSS Injection</title><link>https://xsleaks.dev/docs/attacks/css-injection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/css-injection/</guid><description>&lt;h2 id="css-injection">
 CSS Injection
 &lt;a class="anchor" href="#css-injection">#&lt;/a>
&lt;/h2>

 &lt;blockquote class="book-hint2 warning">
 &lt;p class="hint-title warning">
 &lt;svg class="book-icon">
 &lt;use href="https://xsleaks.dev/svg/hint-icons.svg#warning-notice">&lt;/use>
 &lt;/svg>&lt;span>warning&lt;/span>&lt;/p>
 This group of XS-Leaks requires a CSS injection on the target page.
 &lt;/blockquote>


&lt;p>Among the different CSS injection vectors, the most noticeable one is the abuse of CSS Selectors. They can be used as an expression to match and select certain HTML elements. For example, the selector &lt;code>input[value^=&amp;quot;a&amp;quot;]&lt;/code> is matched if the value of an &lt;code>input&lt;/code> tag starts with the character &amp;ldquo;a&amp;rdquo;. So, to detect if a CSS Selector matches the expression, attackers can trigger a callback to one of their websites using certain properties like &lt;code>background&lt;/code>, &lt;code>@import&lt;/code>, etc. &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. The matching process can easily be brute-forced, and extended to the full string.&lt;/p></description></item></channel></rss>