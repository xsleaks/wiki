<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Secure Defaults on XS-Leaks Wiki</title><link>https://xsleaks.dev/docs/defenses/secure-defaults/</link><description>Recent content in Secure Defaults on XS-Leaks Wiki</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://xsleaks.dev/docs/defenses/secure-defaults/index.xml" rel="self" type="application/rss+xml"/><item><title>Cross-Origin Read Blocking</title><link>https://xsleaks.dev/docs/defenses/secure-defaults/corb/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/secure-defaults/corb/</guid><description>&lt;p>Cross-Origin Read Blocking (CORB) is a security mechanism that prevents attackers from loading certain cross-origin resources &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. This protection was created to defend against speculative side-channel attacks such as Spectre that allow attackers to read the memory of the process that both cross-site pages (e.g. &lt;em>attacker.com&lt;/em> and &lt;em>sensitive.com&lt;/em>) were embedded into. CORB aims to prevent attackers from loading certain sensitive cross-origin resources into an attacker-controlled process. For example, if an attacker tries to load cross-origin HTML, XML, or JSON into an &lt;code>img&lt;/code> tag, CORB prevents this from happening. With CORB, the scenario is treated as though the server returned no data.&lt;/p></description></item><item><title>Partitioned HTTP Cache</title><link>https://xsleaks.dev/docs/defenses/secure-defaults/partitioned-cache/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/secure-defaults/partitioned-cache/</guid><description>&lt;p>In order to defend against cache probing attacks, browser developers are actively working on implementing a partitioned HTTP cache functionality that would in essence ensure each website has a distinct cache. Since cache probing relies on the fact that a browser&amp;rsquo;s HTTP cache is shared across every website, a partitioned HTTP cache can defend against many cache probing techniques. This is done by using tuples (either &lt;code>(top-frame-site, resource-url)&lt;/code> like firefox &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> or &lt;code>(top-frame-site, framing-site, resource-url)&lt;/code>) like chromium/chrome &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> as the cache keys to ensure the cache is partitioned by the requesting site. This makes it more challenging for attackers to interact with the cached contents of different sites &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> &lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> &lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>. Safari currently ships a partitioned cache &lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>.&lt;/p></description></item></channel></rss>