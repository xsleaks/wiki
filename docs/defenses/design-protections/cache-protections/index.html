<!doctype html><html lang=en dir=ZgotmplZ><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Cache Protection"><meta name=theme-color content="#FFFFFF"><meta property="og:url" content="https://xsleaks.dev/docs/defenses/design-protections/cache-protections/"><meta property="og:site_name" content="XS-Leaks Wiki"><meta property="og:title" content="Cache Protections"><meta property="og:description" content="Cache Protection"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2020-10-16T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-11T17:18:06+01:00"><title>Cache Protections | XS-Leaks Wiki</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.3e4293c95aca96b4ee60e121777d22919987757ee0af31973de12f0294bb3e38.css integrity="sha256-PkKTyVrKlrTuYOEhd30ikZmHdX7grzGXPeEvApS7Pjg="><script defer src=/en.search.min.221adc676e09b996f204295099466eb180b67277c164a32aa536a14d37fdfc4d.js integrity="sha256-IhrcZ24JuZbyBClQmUZusYC2cnfBZKMqpTahTTf9/E0="></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk="></script></head><body dir=ZgotmplZ><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/><span>XS-Leaks Wiki</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Attacks</span><ul><li><a href=/docs/attacks/xs-search/>XS-Search</a></li><li><a href=/docs/attacks/window-references/>Window References</a></li><li><a href=/docs/attacks/css-tricks/>CSS Tricks</a></li><li><a href=/docs/attacks/error-events/>Error Events</a></li><li><a href=/docs/attacks/frame-counting/>Frame Counting</a></li><li><a href=/docs/attacks/navigations/>Navigations</a></li><li><a href=/docs/attacks/cache-probing/>Cache Probing</a></li><li><a href=/docs/attacks/element-leaks/>Element leaks</a></li><li><a href=/docs/attacks/id-attribute/>ID Attribute</a></li><li><a href=/docs/attacks/postmessage-broadcasts/>postMessage Broadcasts</a></li><li><span>Browser Features</span><ul><li><a href=/docs/attacks/browser-features/corb/>CORB Leaks</a></li><li><a href=/docs/attacks/browser-features/corp/>CORP Leaks</a></li></ul></li><li><span>Timing Attacks</span><ul><li><a href=/docs/attacks/timing-attacks/clocks/>Clocks</a></li><li><a href=/docs/attacks/timing-attacks/network-timing/>Network Timing</a></li><li><a href=/docs/attacks/timing-attacks/performance-api/>Performance API</a></li><li><a href=/docs/attacks/timing-attacks/execution-timing/>Execution Timing</a></li><li><a href=/docs/attacks/timing-attacks/hybrid-timing/>Hybrid Timing</a></li><li><a href=/docs/attacks/timing-attacks/connection-pool/>Connection Pool</a></li></ul></li><li><a href=/docs/attacks/experiments/ class=collapsed>Experiments</a></li><li><a href=/docs/attacks/css-injection/>CSS Injection</a></li><li><a href=/docs/attacks/historical/ class=collapsed>Historical</a></li></ul></li><li class=book-section-flat><a href=/docs/defenses/>Defense Mechanisms</a><ul><li><a href=/docs/defenses/design-protections/>Application Design</a><ul><li><a href=/docs/defenses/design-protections/cache-protections/ class=active>Cache Protections</a></li><li><a href=/docs/defenses/design-protections/subresource-protections/>Subresource Protections</a></li></ul></li><li><a href=/docs/defenses/opt-in/>Opt-In Mechanisms</a><ul><li><a href=/docs/defenses/opt-in/fetch-metadata/>Fetch Metadata</a></li><li><a href=/docs/defenses/opt-in/coop/>Cross-Origin-Opener-Policy</a></li><li><a href=/docs/defenses/opt-in/corp/>Cross-Origin-Resource-Policy</a></li><li><a href=/docs/defenses/opt-in/xfo/>Framing Protections</a></li><li><a href=/docs/defenses/opt-in/same-site-cookies/>SameSite Cookies</a></li><li><a href=/docs/defenses/opt-in/document-policies/>Document Policies</a></li></ul></li><li><a href=/docs/defenses/isolation-policies/>Isolation Policies</a><ul><li><a href=/docs/defenses/isolation-policies/resource-isolation/>Resource Isolation Policy</a></li><li><a href=/docs/defenses/isolation-policies/framing-isolation/>Framing Isolation Policy</a></li><li><a href=/docs/defenses/isolation-policies/navigation-isolation/>Navigation Isolation Policy</a></li><li><a href=/docs/defenses/isolation-policies/strict-isolation/>Strict Isolation Policy</a></li></ul></li><li><a href=/docs/defenses/secure-defaults/>Secure Defaults</a><ul><li><a href=/docs/defenses/secure-defaults/corb/>Cross-Origin Read Blocking</a></li><li><a href=/docs/defenses/secure-defaults/partitioned-cache/>Partitioned HTTP Cache</a></li></ul></li></ul></li><li class=book-section-flat><a href=/docs/contributions/>Contributions</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Cache Protections</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents></nav></aside></header><article class=markdown><h1>Cache Protections</h1><h5>October 16, 2020</h5><p><p>There are a number of different approaches applications can use to defend against cache probing-based XS-Leaks. These approaches are explained in the following sections.</p><h1 id=cache-protection-via-cache-control-headers>Cache Protection via <code>Cache-Control</code> Headers
<a class=anchor href=#cache-protection-via-cache-control-headers>#</a></h1><p>If it is acceptable to disable caching, doing so provides a strong defense against cache probing attacks. Disabling caching means that every time someone loads a resource, the resource has to be fetched again. To disable caching, set a <code>Cache-Control: no-store</code> header on every single response that you wish to protect.</p><p>Advantages:</p><ul><li>Supported by all major browsers</li></ul><p>Disadvantages:</p><ul><li>Negatively impacts site performance</li></ul><h1 id=cache-protection-via-random-tokens>Cache Protection via Random Tokens
<a class=anchor href=#cache-protection-via-random-tokens>#</a></h1><p>Rather than disabling caching, applications can include additional data in URLs in order to defend against cache probing attacks. This can be achieved by including a random token in the URL of every subresource that you reference. If an attacker cannot guess this random token, then the attacker cannot determine whether items are in the cache via any straightforward techniques.</p><blockquote class="book-hint2 example"><p class="hint-title example"><svg class="book-icon"><use href="/svg/hint-icons.svg#example-notice"/></svg><span>example</span></p><p>Suppose that every page on your application loads the user&rsquo;s profile photo: <code>/user/&lt;USERNAME>.png</code>. An attacker could check which user is signed in by probing the cache for <code>/user/john.png</code>, <code>/user/jane.png</code>, and so on.</p><p>This is where a random token can come into play. If implemented, the application takes the user&rsquo;s profile photo from <code>/user/&lt;USERNAME>.png?cache_buster=&lt;RANDOM_TOKEN></code> on every load. The server does not need to do anything with this random token. It is there purely to ensure that there is no way for an attacker to probe the cache without knowing the random token.</p></blockquote><p>If implemented carefully, an application could even have a user-specific random token that is reused across page loads. This would allow subresources to still be cached since the URL would remain constant for a given user.</p><p>Advantages:</p><ul><li>Supported by every major browser</li><li>Does not break caching</li></ul><p>Disadvantages:</p><ul><li>Difficult to implement</li></ul><h1 id=cache-protection-via-fetch-metadata>Cache Protection via Fetch Metadata
<a class=anchor href=#cache-protection-via-fetch-metadata>#</a></h1><p><a href=https://xsleaks.dev/docs/defenses/opt-in/fetch-metadata/>Fetch-Metadata</a> is meant to allow servers to determine how and why a request was initiated on the client side. One piece of information that is exposed is the <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site><code>Sec-Fetch-Site</code></a> header which specifies whether a request is coming from the same origin or a different origin. This can be combined with the <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Vary><code>Vary</code></a> header in order to force the browser to segment the cache based on whether a request is made from the same origin or a different origin.</p><p>This is done by setting <code>Vary: Sec-Fetch-Site</code> on all resources you wish to protect.</p><blockquote class="book-hint2 example"><p class="hint-title example"><svg class="book-icon"><use href="/svg/hint-icons.svg#example-notice"/></svg><span>example</span></p><p>Assume we have the resource <code>cdn.example.com/image.png</code> that we wish to protect from cache probing attacks. If we set <code>Vary: Sec-Fetch-Site</code> on it, this leads to the following behavior:</p><ol><li>If <code>example.com</code> tries to load the resource, the request is initiated by the same site so it is cached under <code>(SFS: same-site, resource_url)</code></li><li>If <code>cdn.example.com</code> tries to load the resource, the request is initiated by the same origin so it is cached under <code>(SFS: same-origin, resource_url)</code></li><li>If <code>evil.com</code> tries to load the resource, the request is initiated by a different site so it is cached under <code>(SFS: cross-site, resource_url)</code></li></ol><p>Note that this means cross-site requests are separated from same-site and same-origin requests.</p></blockquote><p>Advantages:</p><ul><li>Does not break caching</li></ul><p>Disadvantages:</p><ul><li>Fetch metadata is a new standard that is currently only supported in Chromium-based browsers (e.g. Chrome and Edge)</li><li>Cross-site subresources loaded on the page are not protected (e.g. subresources from CDNs)</li><li>If third parties load the resource, they are not protected</li></ul></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/xsleaks/wiki/commit/7f52379202f21cdd3063874f4c9f433f11cac9f2 title='Last modified by terjanq | November 11, 2020' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Last Modified: November 11, 2020</span></a></div><div><a class="flex align-center" href=https://github.com/xsleaks/wiki/edit/master/content/docs/defenses/design-protections/cache-protections.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this article</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents></nav></aside></main></body></html>