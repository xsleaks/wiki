<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Framing Protections on XS-Leaks Wiki</title><link>https://xsleaks.dev/defenses/framing-protections/</link><description>Recent content in Framing Protections on XS-Leaks Wiki</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 10 May 2025 00:10:20 +0200</lastBuildDate><atom:link href="https://xsleaks.dev/defenses/framing-protections/index.xml" rel="self" type="application/rss+xml"/><item><title>CSS Tricks</title><link>https://xsleaks.dev/docs/attacks/css-tricks/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/css-tricks/</guid><description>&lt;h2 id="css-tricks">
 CSS Tricks
 &lt;a class="anchor" href="#css-tricks">#&lt;/a>
&lt;/h2>
&lt;p>CSS can be used to trick a user into exposing information such as embedded pixel values by making visual changes that are affected by the embed.&lt;/p>
&lt;h2 id="retrieving-users-history">
 Retrieving user&amp;rsquo;s history
 &lt;a class="anchor" href="#retrieving-users-history">#&lt;/a>
&lt;/h2>
&lt;p>Using the CSS &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:visited">&lt;code>:visited&lt;/code>&lt;/a> selector, itâ€™s possible to apply a different style for URLs that have been visited.&lt;br>
Previously it was possible to use &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle">&lt;code>getComputedStyle()&lt;/code>&lt;/a> to detect this difference, but now browsers prevent this by always returning values as if the link was visited and limiting what styles can be applied using the selector. &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;br>
So, it may be needed to trick the user into clicking an area that the CSS has affected.
This can be done using &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode">&lt;code>mix-blend-mode&lt;/code>&lt;/a>. &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;br>
There are also ways to do it without user interaction such as by abusing render timings.
This works because it takes time to paint links in a different color. &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;br>
A Proof of Concept to this attack can be found in a Chromium report &lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> and it works by having multiple links to increase the time difference.&lt;/p></description></item><item><title>Frame Counting</title><link>https://xsleaks.dev/docs/attacks/frame-counting/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/frame-counting/</guid><description>&lt;p>Window references allow cross-origin pages to get access to some of the attributes of other pages. These references become available when using or allowing &lt;code>iframe&lt;/code> and &lt;code>window.open&lt;/code>. The references provide (limited) information about the window as they still respect the same-origin policy.&lt;/p>
&lt;p>One of the accessible attributes is &lt;code>window.length&lt;/code> which provides the number of frames in the window. This attribute can provide valuable information about a page to an attacker.&lt;/p></description></item><item><title>Navigations</title><link>https://xsleaks.dev/docs/attacks/navigations/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/navigations/</guid><description>&lt;p>Detecting if a cross-site page triggered a navigation (or didn&amp;rsquo;t) can be useful to an attacker. For example, a website may trigger a navigation in a certain endpoint &lt;a href="#case-scenarios">depending on the status of the user&lt;/a>.&lt;/p>
&lt;p>To detect if any kind of navigation occurred, an attacker can:&lt;/p>
&lt;ul>
&lt;li>Use an &lt;code>iframe&lt;/code> and count the number of times the &lt;code>onload&lt;/code> event is triggered.&lt;/li>
&lt;li>Check the value of &lt;code>history.length&lt;/code>, which is accessible through any window reference. This provides the number of entries in the history of a victim that were either changed by &lt;code>history.pushState&lt;/code> or by regular navigations. To get the value of &lt;code>history.length&lt;/code>, an attacker changes the location of the window reference to the target website, then changes back to same-origin, and finally reads the value. &lt;a href="https://xsinator.com/testing.html#History%20Length%20Leak">Run demo&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="download-trigger">
 Download Trigger
 &lt;a class="anchor" href="#download-trigger">#&lt;/a>
&lt;/h2>
&lt;p>When an endpoint sets the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition">&lt;code>Content-Disposition: attachment&lt;/code>&lt;/a> header, it instructs the browser to download the response as an attachment instead of navigating to it. Detecting if this behavior occurred might allow attackers to leak private information if the outcome depends on the state of the victim&amp;rsquo;s account.&lt;/p></description></item><item><title>Network Timing</title><link>https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/</guid><description>&lt;p>Network Timing side-channels have been present on the web since its inception &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. These attacks have had different levels of impact over time, gaining new attention when browsers started shipping high-precision timers like &lt;a href="https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow">performance.now()&lt;/a>.&lt;/p>
&lt;p>To obtain timing measurements, attackers must use a &lt;a href="https://xsleaks.dev/docs/attacks/timing-attacks/clocks/">clock&lt;/a>, either an implicit or an explicit one. These clocks are usually interchangeable for the purposes of XS-Leaks and only vary in accuracy and availability. For simplicity, this article assumes the use of the &lt;code>performance.now()&lt;/code> API, an explicit clock present in all modern browsers.&lt;/p></description></item><item><title>Execution Timing</title><link>https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/</guid><description>&lt;p>Measuring the time of JavaScript execution in a browser can give attackers information on when certain events are triggered, and how long some operations take.&lt;/p>
&lt;h2 id="timing-the-event-loop">
 Timing the Event Loop
 &lt;a class="anchor" href="#timing-the-event-loop">#&lt;/a>
&lt;/h2>
&lt;p>JavaScript&amp;rsquo;s concurrency model is based on a &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">single-threaded event loop&lt;/a> which means it can only run one task at a time. If, for example, some time-consuming task blocks the event loop, the user can perceive a freeze on a page as a result of the UI thread being starved. Other tasks must wait until the blocking task finishes. Each browser implements different &lt;a href="https://chromium.googlesource.com/chromium/src/&amp;#43;/main/docs/process_model_and_site_isolation.md">process models&lt;/a>, which means some web sites might run in different threads (and event loops) depending on their relations.&lt;/p></description></item><item><title>ID Attribute</title><link>https://xsleaks.dev/docs/attacks/id-attribute/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/attacks/id-attribute/</guid><description>&lt;p>The &lt;code>id&lt;/code> attribute is widely used to identify &lt;code>HTML&lt;/code> elements. Unfortunately, cross-origin websites can determine whether a given &lt;code>id&lt;/code> is set anywhere on a page by leveraging the &lt;code>focus&lt;/code> event and &lt;code>URL&lt;/code> fragments. If &lt;code>https://example.com/foo#bar&lt;/code> is loaded, the browser attempts to scroll to the element with &lt;code>id=&amp;quot;bar&amp;quot;&lt;/code>. This can be detected cross-origin by loading &lt;code>https://example.com/foo#bar&lt;/code> in an iframe; if there is an element with &lt;code>id=&amp;quot;bar&amp;quot;&lt;/code>, the &lt;code>focus&lt;/code> event fires. The &lt;code>blur&lt;/code> event can also be used for the same purpose &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>.&lt;/p></description></item></channel></rss>